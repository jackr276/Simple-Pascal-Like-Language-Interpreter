# Interpreter for a Simple Pascal-like Programming Language
Author : [Jack Robbins](https://github.com/jackr276)

## Executive Summary
This project is an interpreter for an interpreted Pascal-like programming language. Interpreted languages, such as the language in this project and more well known ones like **Python** and **R**, are executed line-by-line, as opposed to compiled languages where programs are translated into machine code all at once before execution.  The interpreter for this language is made up of two main copmonents, a [tokenizer/lexical analyzer](https://github.com/jackr276/Simple-Pascal-Like-Language-Interpreter/blob/main/lex.cpp), and a [recursive-descent parser/interpreter](https://github.com/jackr276/Simple-Pascal-Like-Language-Interpreter/blob/main/parserInterp.cpp). To help show how this programming language is supposed to look and function, there are numerous example programs provided in the [tests folder](https://github.com/jackr276/Simple-Pascal-Like-Language-Interpreter/tree/main/tests). If you are interested, I would greatly encourage you to read the formal write-up below, download the code, and write some
programs for yourself in this programming langauge.

>[!Note]
>There is adequate documentation within the source code itself, but for a full theoretical understanding of this project, I strongly recommend reading the full write-up that follows this executive summary.

## Extended Backus-Naur Form(EBNF) Meta-syntax
EBNF is a notation/ruleset for formally describing context-free grammars. Context-free grammars are the theoretical foundation for all programming languages. The formal language generated by a context-free grammar is the set of terminal strings that can be produced by the grammar rules.

Mathematically, any context-free grammar _G_ is defined as the 4-tuple $G = (V, \Sigma, R, S)$, such that
 1. $V$ is the finite set of all non-terminals $v \in V$ where each element _v_ is a non-terminal character. Every non-terminal character is a character that cannot be changed the rules of the language.
 2. $\Sigma$ is the finite set of all terminals such that $\Sigma \cap V = \varnothing$. The set of terminals are defined by the language.
 3. $R$ is a finite subset of the binary relation defined as $V \times (V \cup \Sigma)^\*$ where $\beta \in (V \cup \Sigma)^\*$ is a string of variables/terminals.
 5. $S$ is the start/entry symbol for the program. It is necessary that $S \in V$.

>[!Important]
> Listed below is the notation that will be used in the formal EBNF definition of this programming language in the next section. It is important that this notation is understood before reading the rules for this language.


| Usage | Notation | Description |
| ----- | -------- | -------------- |
| Terminal String | Any text enclosed in single quotes (' ')| Terminals are the lexical foundation of the language. They are symbols that cannot be changed using the rules of the grammar. The final output after applying all grammar rules will be a string of terminals |
| Nonterminal String | Any **bolded** text | | Nonterminals, or _syntactic variables_, are symbols that can be replaced. |
|Repetition Operator|{}|Indicates that the sequence of terminals and nonterminals inside may be repeated _0 or more times_|



## EBNF Rules For This Language

## Compiling/Running this program
