# Interpreter for a Simple Pascal-like Programming Language
Author : [Jack Robbins](https://github.com/jackr276)

## Executive Summary
This project is an interpreter for an interpreted Pascal-like programming language. Interpreted languages, such as the language in this project and more well known ones like **Python** and **R**, are executed line-by-line, as opposed to compiled languages where programs are translated into machine code all at once before execution.  The interpreter for this language is made up of two main copmonents, a [tokenizer/lexical analyzer](https://github.com/jackr276/Simple-Pascal-Like-Language-Interpreter/blob/main/lex.cpp), and a [recursive-descent parser/interpreter](https://github.com/jackr276/Simple-Pascal-Like-Language-Interpreter/blob/main/parserInterp.cpp). To help show how this programming language is supposed to look and function, there are numerous example programs provided in the [tests folder](https://github.com/jackr276/Simple-Pascal-Like-Language-Interpreter/tree/main/tests). If you are interested, I would greatly encourage you to read the formal write-up below, download the code, and write some
programs for yourself in this programming langauge.

>[!Note]
>There is adequate documentation within the source code itself, but for a full theoretical understanding of this project, I strongly recommend reading the full write-up that follows this executive summary.

## Extended Backus-Naur Form(EBNF) Meta-syntax
EBNF is a notation/ruleset for formally describing context-free grammars. Context-free grammars are the theoretical foundation for all programming languages. The formal language generated by a context-free grammar is the set of terminal strings that can be produced by the grammar rules.

Mathematically, any context-free grammar _G_ is defined as the 4-tuple $G = (V, \Sigma, R, S)$, such that
 1. $V$ is the finite set of all non-terminals $v \in V$ where each element _v_ is a non-terminal character. Every non-terminal character is a character that cannot be changed the rules of the language.
 2. $\Sigma$ is the finite set of all terminals such that $\Sigma \cap V = \varnothing$. The set of terminals are defined by the language.
 3. $R$ is a finite subset of the binary relation defined as $V \times (V \cup \Sigma)^\*$ where $\beta \in (V \cup \Sigma)^\*$ is a string of terminals and non-terminals.
 5. $S$ is the start/entry symbol for the program. It is necessary that $S \in V$.

With this, we have explored the mathematical foundation for context-free grammars. As stated above, EBNF meta-syntax is used to describe context-free grammars, which are the foundation for all programming languages, including the langauge inmplemented in this project. The table below is a handy "cheat sheet" that contains everything that you need to know to understand the EBNF rules for this language.

>[!Important]
> Listed below is the notation that will be used in the formal EBNF definition of this programming language in the next section. It is important that this notation is understood before reading the rules for this language.


| Usage | Notation | Description |
| ----- | -------- | -------------- |
| Language Terminals | Any UPPERCASE text| Terminals are the lexical foundation of the language. They are symbols that cannot be changed using the rules of the grammar. The final output after applying all grammar rules will be a string of terminals. The terminals that are in this language are further defined below|
| Language Nonterminals | Any **bolded** text | Nonterminals, or _syntactic variables_, are symbols that can be replaced. |
|Optional Repetition|{. . . . .}|Indicates that the sequence of terminals and nonterminals inside may be repeated _0 or many times_|
|Optional Inclusion|[. . . . .]|Indicates that the sequence of terminals and nonterminals inside may be used _not at all or 1 time_|
|Grouping|(. . . . .)|Indicates that the sequence of terminals and nonterminals inside are grouped together. Usually seen used with the \| operator|
|Concatenation|    ,    |Inidicates concatenation of items |
|Alternation|    \|    |Indicates that items on the left or right are used "either-or"|
|Definition| ::= | The non-terminal on the left of the definition operator is defined as the sequence of terminals and nonterminals on the right of the operator|

With this brief introduction in mind, let's take a look at the EBNF ruleset for the language implemented in this project.

## EBNF Rules For This Language

 1. **Prog** ::= PROGRAM IDENT ; **DeclPart** **CompoundStmt**
 2. **DeclPart** ::= VAR **DeclStmt** { ; **DeclStmt** }
 3. **DeclStmt** ::= IDENT {, IDENT } : **Type** [:= **Expr**]
 4. **Type** ::= INTEGER | REAL | BOOLEAN | STRING
 5. **Stmt** ::= **SimpleStmt** | **StructuredStmt**
 6. **SimpleStmt** ::= **AssignStmt** | **WriteLnStmt** | **WriteStmt**
 7. **StructuredStmt** ::= **IfStmt** | **CompoundStmt**
 8. **CompoundStmt** ::= BEGIN **Stmt** {; **Stmt** } END
 9. **WriteLnStmt** ::= WRITELN (**ExprList**)
 10. **WriteStmt** ::= WRITE (**ExprList**)
 11. **IfStmt** ::= IF **Expr** THEN **Stmt** [ ELSE **Stmt** ]
 12. **AssignStmt** ::= **Var** := **Expr**
 13. **Var** ::= IDENT
 14. **ExprList** ::= **Expr** { , **Expr** }
 15. **Expr** ::= **LogOrExpr** ::= **LogAndExpr** { OR **LogAndExpr** }
 16. **LogAndExpr** ::= **RelExpr** {AND **RelExpr** }
 17. **RelExpr** ::= **SimpleExpr** [ ( = | < | > ) **SimpleExpr** ]
 18. **SimpleExpr** :: **Term** { ( + | - ) **Term** }
 19. **Term** ::= **SFactor** { ( * | / | DIV | MOD ) **SFactor** }
 20. **SFactor** ::= [( - | + | NOT )] **Factor**
 21. **Factor** ::= IDENT | ICONST | RCONST | SCONST | BCONST | (**Expr**)

Additionally, there are specific rules for the different types of terminals that our language has, listed below.
| Terminals | Description | Regular Expression Notation | Valid Examples | Invalid Examples |
|----|---------|------|-------|----|
|IDENT| An identifier is a user-defined program variable| IDENT := Letter {( Letter \| Digit \| _ \| $ )} <br /> Letter := [ a-z A-Z ] <br /> Digit := [0-9]|hello$, myVar, first_name|$hello, 1st_name, _name|
|SCONST|A string constant is defined as a sequence of characters enclosed in single quotes|SCONST := 'Any Character string'|'Hello $5 #., s9 my name is', 'hello'|"This is an invalid string due to the double quotes"|
|ICONST|An integer constant is any valid integer|ICONST := [0-9]+|2, 200, 3444|-68, 9.56|
|RCONST|A real constant is any valid real number|RCONST := ([0-9]+)\.([0-9]*)|9.01, 0.2, 2.|.2, 2.3.4|
|BCONST|A boolean constant is either true or false| BCONST := (true \| false)|true, false|tRuE, FALSE|






## Compiling/Running this program
